<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]--><!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]--><!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]--><!--[if gt IE 8]><!--><!--<![endif]--><head>
<meta charset="utf-8">
<!-- http://t.co/dKP3o1e --><meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>A primer's note for parallel programming in Haskell | Yen3's note</title>
<link href="../../../assets/css/rst.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/main.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/extra.css" rel="stylesheet" type="text/css">
<!-- Webfonts --><link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">
<!-- Load Modernizr --><script src="//mmistakes.github.io/hpstr-jekyll-theme/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="https://yen3.github.io/posts/2016/20160405_a-primer-s-note-for-parallel-programming-in-haskell/">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Yen3">
<link rel="prev" href="../../2015/20151227_murmur-text-file-format/" title="murmur (10) - mkd &amp; LaTeX" type="text/html">
<link rel="next" href="../20160621_instasll-agda-in-mac-osx/" title="Instasll agda in Mac OSX" type="text/html">
<meta property="og:site_name" content="Yen3's note">
<meta property="og:title" content="A primer's note for parallel programming in Haskell">
<meta property="og:url" content="https://yen3.github.io/posts/2016/20160405_a-primer-s-note-for-parallel-programming-in-haskell/">
<meta property="og:description" content="Functional Thursday #33
2015.12.03
Yen3 (yen3rc@gmail.com)


About the slide


這份投影片是 Parallel and Concurrent Programming in Haskell -
  Chatper 1 ~ 5 的筆記


主題包含 

Eval monad 
Par monad
Repa



今天的內容皆">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2016-04-05T11:57:05+08:00">
<meta property="article:tag" content="all">
<meta property="article:tag" content="haskell">
<meta property="article:tag" content="note">
</head>
<body id="post-index" class="feature">
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    

    <nav id="dl-menu" class="dl-menuwrapper" role="navigation"><button class="dl-trigger">Open Menu</button>
    <ul class="dl-menu">
<li><a href="../../../archive.html">Archive</a></li>
            <li><a href="../../../categories/">Tags</a></li>
            <li><a href="../../../rss.xml">RSS feed</a></li>
    
    
    </ul></nav><div class="entry-header">
<!-- FIXME: get credit from settings -->
    <div class="entry-image"> --&gt;
    </div>
<!-- /.entry-image --> 
      
  <div class="header-title">
    <div class="header-title-wrap">
    <h1 id="brand"><a href="https://yen3.github.io/" title="Yen3's note" rel="home">
    Yen3's note</a></h1>
     <!--<h2>A primer's note for parallel programming in Haskell</h2>-->
    </div>
<!-- /.header-title-wrap -->
  </div>
<!-- /.header-title -->

</div>
<!-- /.entry-header -->

    <div id="main" role="main">
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><div class="entry-meta">
            <span class="dateline"><a href="." rel="bookmark"><time class="published dt-published" datetime="2016-04-05T11:57:05+08:00" itemprop="datePublished" title="2016-04-05 11:57">2016-04-05 11:57</time></a></span>  ·  
            <span class="byline author vcard">Yen3</span>  ·  
                <span class="commentline">
        
    <a href="#disqus_thread" data-disqus-identifier="cache/posts/2016/20160405_a-primer-s-note-for-parallel-programming-in-haskell.html">Comments</a>

</span>  ·  
            
        <span class="sourceline"><a href="index.md" id="sourcelink">Source</a></span>  ·  

        </div>
        

    
    <h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">A primer's note for parallel programming in Haskell</a></h1>

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<ul>
<li>Functional Thursday #33</li>
<li>2015.12.03</li>
<li>Yen3 (yen3rc@gmail.com)</li>
</ul>
<hr>
<h4>About the slide</h4>
<ul>
<li>
<p>這份投影片是 <a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a> -
  Chatper 1 ~ 5 的筆記</p>
</li>
<li>
<p>主題包含 </p>
<ul>
<li>Eval monad </li>
<li>Par monad</li>
<li>Repa</li>
</ul>
</li>
<li>
<p>今天的內容皆與 data-level parallelism 相關 </p>
</li>
<li>在 Haskell 中，一個較容易平行化 function 是 <code>map</code>，這份投影片會很常
  討論到它。</li>
</ul>
<hr>
<h4>Definition of Parallel</h4>
<ul>
<li>A <strong>parallel</strong> program is one that uses a multiplicity of computational
  hardware (e.g., several processor cores) to perform a computation more
  quickly.</li>
<li>Parallel programming in Haskell is deterministic: The parallel program always
  produces the same answer, regardless of how many processors are used to run
  it.</li>
</ul>
<!-------><!--## Self-study --><!--- 在進入正題之前，先談幾個小筆記--><!--- Normal form, weak-head normal form and `force` function--><!--- unboxed type & boxed type--><!--- Bang patterns--><!--- Data.Vector package--><hr>
<h4>The status of value in ghc (1/)</h4>
<ul>
<li>There are three conditions of a value.<ul>
<li>Unevaluated </li>
<li>Weak-Head Normal Form (WHNF) - evaluated with first constructor</li>
<li>Normal Form (NF) - fully evaluated</li>
</ul>
</li>
</ul>
<hr>
<h4>The status of value in ghc (2/)</h4>
<ul>
<li>
<code>sprint</code> - prints a value without forcing its evaluation</li>
<li>
<code>seq</code>: only far as the first constructor and doesn't evaluate any more of
  the structure. It evaluates first argument to WHNF.</li>
</ul>
<pre class="code literal-block"><span class="nf">seq</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre>


<hr>
<h4>The status of value in ghc (3/)</h4>
<ul>
<li>Example </li>
</ul>
<pre class="code literal-block"><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">x</span>
<span class="nf">x</span> <span class="ow">=</span> <span class="kr">_</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">y</span>
<span class="nf">y</span> <span class="ow">=</span> <span class="kr">_</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">seq</span> <span class="n">y</span> <span class="nb">()</span>
<span class="nb">()</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">x</span>
<span class="nf">x</span> <span class="ow">=</span> <span class="mi">3</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">y</span>
<span class="nf">y</span> <span class="ow">=</span> <span class="mi">4</span>
</pre>


<hr>
<h4>The status of value in ghc (4/)</h4>
<pre class="code literal-block"><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">xs</span>
<span class="nf">xs</span> <span class="ow">=</span> <span class="kr">_</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">seq</span> <span class="n">xs</span> <span class="nb">()</span>
<span class="nb">()</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">xs</span>
<span class="nf">xs</span> <span class="ow">=</span> <span class="kr">_</span> <span class="kt">:</span> <span class="kr">_</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">length</span> <span class="n">xs</span>
<span class="mi">10</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">xs</span>
<span class="nf">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">]</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="n">xs</span>
<span class="mi">65</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">xs</span>
<span class="nf">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
</pre>


<hr>
<h4>
<code>force</code> function</h4>
<ul>
<li>
<code>force</code> - fully evaluated it's argument and returns it. (WHNF into NF)</li>
</ul>
<pre class="code literal-block"><span class="kr">import</span> <span class="nn">Control.DeepSeq</span>

<span class="kr">class</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">rnf</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="nb">()</span>      <span class="c1">-- reduce to normal-form</span>
    <span class="n">rnf</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="nb">()</span>

<span class="nf">deepseq</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">deepseq</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">rnf</span> <span class="n">a</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">b</span> 

<span class="nf">force</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>   
<span class="nf">force</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">deepseq</span><span class="p">`</span> <span class="n">x</span>
</pre>


<ul>
<li>
<code>seq</code>: only far as the first constructor and doesn't evaluate any more of
  the structure. It evaluates first argument to WHNF.</li>
</ul>
<!-- deepseq: fully evaluates its argument and then returns () --><hr>
<h4>Eval monad</h4>
<ul>
<li>Decoupling of the algorithm from the parallelism</li>
<li>The type declaration for eval monad </li>
</ul>
<pre class="code literal-block"><span class="kr">data</span> <span class="kt">Eval</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Eval</span>

<span class="nf">runEval</span> <span class="ow">::</span> <span class="kt">Eval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">rpar</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="n">a</span>   <span class="c1">-- rpar :: Strategy a </span>
<span class="nf">rseq</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="n">a</span>   <span class="c1">-- rseq :: Strategy a</span>
</pre>


<ul>
<li>
<code>rpar</code> - evaluate its argument in parallel.</li>
<li>
<code>rseq</code> - Evaluate the argument and wait for the result.<ul>
<li>evaluates its argument to WHNF.</li>
</ul>
</li>
</ul>
<!--
- The argument of `rpar` is also named **spark**.
--><hr>
<h4>Eval monad - simple example</h4>
<ul>
<li>Example</li>
</ul>
<pre class="code literal-block"><span class="nf">runEval</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">rseq</span> <span class="p">(</span><span class="n">f</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">rseq</span> <span class="n">a</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre>


<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/24606632@N05/26219016196/in/dateposted-public/" title="eval_monad_simple_example"><img src="https://farm2.staticflickr.com/1717/26219016196_6d47d9e102.jpg" width="800" height="328" alt="eval_monad_simple_example"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
<hr>
<h4>Eval monad - Strategy</h4>
<ul>
<li>Strategy - modularize parllel code by separating the algorithm from the
  parallelism <ul>
<li>use <code>using</code> function to add parallelism with the existing codes</li>
<li>
<code>withStrategy</code>- a another version of <code>using</code> with the arguments flipped</li>
</ul>
</li>
</ul>
<pre class="code literal-block"><span class="kr">type</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="n">a</span>

<span class="nf">using</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">x</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">runEval</span> <span class="p">(</span><span class="n">s</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">withStrategy</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">withStrategy</span> <span class="n">s</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">runEval</span> <span class="p">(</span><span class="n">s</span> <span class="n">x</span><span class="p">)</span>
</pre>


<hr>
<h4>Eval monad - Strategy</h4>
<ul>
<li>The <code>rpar</code>, <code>rseq</code> are also Strategies.</li>
</ul>
<pre class="code literal-block"><span class="nf">rpar</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span>
<span class="nf">rseq</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span>
</pre>


<ul>
<li>You could write the algorithm first and add the parallelism code later
  ideally.</li>
</ul>
<hr>
<h4>Eval monad - example for pair</h4>
<ul>
<li>Example</li>
</ul>
<pre class="code literal-block"><span class="kr">import</span> <span class="nn">Control.Parallel.Strategies</span>
<span class="kr">import</span> <span class="nn">Control.DeepSeq</span>

<span class="nf">evalPair</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="nf">evalPair</span> <span class="n">sa</span> <span class="n">sb</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a'</span> <span class="ow">&lt;-</span> <span class="n">sa</span> <span class="n">a</span>
    <span class="n">b'</span> <span class="ow">&lt;-</span> <span class="n">sb</span> <span class="n">b</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a'</span><span class="p">,</span><span class="n">b'</span><span class="p">)</span>
</pre>


<hr>
<h4>Eval monad - example for pair</h4>
<pre class="code literal-block"><span class="nf">rparWith</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span>
<span class="nf">rparWith</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span>
    <span class="kr">do</span>
        <span class="n">ra</span> <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="n">a</span>
        <span class="n">sa</span> <span class="ow">&lt;-</span> <span class="n">s</span> <span class="n">ra</span>
        <span class="n">return</span> <span class="n">sa</span> 

<span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span>             <span class="c1">-- (1-1)  </span>
<span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1">-- (1-2)</span>

<span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">rpar</span>   <span class="c1">-- (2-1)</span>
<span class="o">&lt;!--</span><span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">evalPair</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">rseq</span><span class="p">)</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">rseq</span><span class="p">)</span>  <span class="c1">-- (2-2)--&gt;</span>
<span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">evalPair</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">rseq</span><span class="p">)</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">rseq</span><span class="p">)</span>  <span class="c1">-- (2-2)</span>
</pre>


<ul>
<li>(1-1), (1-2) - sequential version</li>
<li>(2-1), (2-2) - parallel version and reduce the value to WHNF</li>
</ul>
wzxhzdk:10


- (3-1), (3-2) - parallel version and reduce the value to NF 
- `parTuple2` and `evalPair` functions are the same
--&gt;

<hr>
<h4>Eval monad - some help functions (1/)</h4>
<ul>
<li>About some helper function<ul>
<li>
<code>rdeepseq</code> - evaluates the argument to NF </li>
</ul>
</li>
</ul>
<pre class="code literal-block"><span class="nf">rdeepseq</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span>
<span class="nf">rdeepseq</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">rseq</span> <span class="p">(</span><span class="n">force</span> <span class="n">x</span><span class="p">)</span>
</pre>


<pre class="code literal-block">- `rparWith` - wraps the Strategy s in an `rpar`
</pre>


<pre class="code literal-block"><span class="nf">rparWith</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span> 
</pre>


<hr>
<h4>Eval monad - some help functions (2/)</h4>
<ul>
<li>The code reduced to NF in previous slide could also be written as </li>
</ul>
<pre class="code literal-block"><span class="c1">-- NF </span>
<span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">rparWith</span> <span class="n">rdeepseq</span> 
<span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span>
    <span class="n">evalPair</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">rdeepseq</span><span class="p">)</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">rdeepseq</span><span class="p">)</span>
</pre>


<hr>
<h4>Eval monad - parallelize <code>map</code>
</h4>
<pre class="code literal-block"><span class="nf">parMap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">parMap</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">f</span> <span class="n">x</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">rseq</span> 

<span class="nf">evalList</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">evalList</span> <span class="n">start</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">[]</span>
<span class="nf">evalList</span> <span class="n">start</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x'</span> <span class="ow">&lt;-</span> <span class="n">start</span> <span class="n">x</span>
    <span class="n">xs'</span> <span class="ow">&lt;-</span> <span class="n">evalList</span> <span class="n">start</span> <span class="n">xs</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">x'</span><span class="kt">:</span> <span class="n">xs'</span><span class="p">)</span>

<span class="nf">parList</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">parList</span> <span class="n">start</span> <span class="ow">=</span> <span class="n">evalList</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">start</span><span class="p">)</span>
</pre>


<ul>
<li>
<code>parMap</code> will calculate its list to WHNF</li>
<li>
<code>parList</code> - evaluate the list element in parallel </li>
</ul>
<hr>
<h4>Eval monad</h4>
<ul>
<li>Example</li>
</ul>
<pre class="code literal-block"><span class="kr">import</span> <span class="nn">Control.Parallel.Strategies</span>
<span class="kr">import</span> <span class="nn">Control.DeepSeq</span>

<span class="nf">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>  <span class="c1">-- (1) </span>
<span class="nf">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">rseq</span> <span class="c1">-- (2)</span>
<span class="nf">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">rdeepseq</span>  <span class="c1">-- (3)</span>
</pre>


<ul>
<li>(1) sequential version</li>
<li>(2) parallelize version reduce value to WHNF</li>
<li>(3) parallelize version reduce value to NF </li>
</ul>
<hr>
<h4>Example - Mandelbrot set</h4>
<ul>
<li>
<p>You could get more details
  from <a href="https://yen3.github.io/posts/2015/20150625_haskell-practice-mandelbrot-binary/">my blog post</a>.</p>
</li>
<li>
<p>some type define</p>
</li>
</ul>
<pre class="code literal-block"><span class="kr">type</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">Range</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">Plane</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Range</span><span class="p">,</span> <span class="kt">Range</span><span class="p">)</span>
</pre>


<ul>
<li>sequential version</li>
</ul>
<pre class="code literal-block"><span class="nf">planePoints</span> <span class="ow">::</span> <span class="kt">Plane</span> <span class="ow">-&gt;</span> <span class="kt">V</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Point</span>

<span class="nf">mandelSet</span> <span class="ow">::</span> <span class="kt">Plane</span> <span class="ow">-&gt;</span> <span class="kt">V</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Point</span>
<span class="nf">mandelSet</span> <span class="ow">=</span> <span class="n">planeToMandelPoints</span>
</pre>


<hr>
<h4>Example - Mandelbrot set</h4>
<ul>
<li>basic parallel version with <code>parList</code>
</li>
</ul>
<pre class="code literal-block"><span class="nf">splitPlane</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Plane</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Plane</span><span class="p">]</span>

<span class="nf">mandelSetStart</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Plane</span> <span class="ow">-&gt;</span> <span class="kt">V</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Point</span>
<span class="nf">mandelSetStart</span> <span class="n">size</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">V</span><span class="o">.</span><span class="n">concat</span>
    <span class="p">(</span><span class="n">map</span> <span class="n">planeToMandelPoints</span> <span class="p">(</span><span class="n">splitPlane</span> <span class="n">size</span> <span class="n">p</span><span class="p">)</span>
     <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">rseq</span><span class="p">)</span>
</pre>


<ul>
<li>In  2010 late MBP15 (Intel Core i5 2.4 Ghz, 8Gb)<ul>
<li>sequential - about 45 secs</li>
<li>run in 2 cores - about 25 secs (<code>./Mandelbrot par 100 +RTS -N2 -s</code>)</li>
</ul>
</li>
</ul>
<hr>
<h4>Par Monad</h4>
<ul>
<li>
<strong>Goal</strong><ul>
<li>be more explicit about granularity and data dependences </li>
<li>Avoid the reliance on lazy evaluation, but without sacrificing the
  determinism that we value for parallel programming.</li>
<li>The parallel computations are pure (and deterministic)</li>
</ul>
</li>
<li>The library is implemented entirely as a Haskell library<ul>
<li>You can accommodate alternative scheduling strategies.</li>
</ul>
</li>
</ul>
<hr>
<h4>Par Monad</h4>
<ul>
<li>Par monad - a monad for parallel computation </li>
</ul>
<pre class="code literal-block"><span class="kr">newtype</span> <span class="kt">Par</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Par</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Par</span>

<span class="nf">runPar</span> <span class="ow">::</span> <span class="kt">Par</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>    <span class="c1">-- produce a pure result.</span>
<span class="nf">fork</span> <span class="ow">::</span> <span class="kt">Par</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="nb">()</span> <span class="c1">-- the way to create parallel tasks</span>
</pre>


<ul>
<li>IVar - results are communicated through IVars</li>
</ul>
<pre class="code literal-block"><span class="kr">data</span> <span class="kt">IVar</span> <span class="n">a</span> 

<span class="nf">new</span> <span class="ow">::</span> <span class="kt">Par</span> <span class="p">(</span><span class="kt">IVar</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">put</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">IVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="nb">()</span>
<span class="nf">get</span> <span class="ow">::</span> <span class="kt">IVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="n">a</span>
</pre>


<hr>
<h4>Par Monad</h4>
<ul>
<li>IVar</li>
</ul>
<pre class="code literal-block"><span class="kr">data</span> <span class="kt">IVar</span> <span class="n">a</span> 

<span class="nf">new</span> <span class="ow">::</span> <span class="kt">Par</span> <span class="p">(</span><span class="kt">IVar</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">put</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">IVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="nb">()</span>
<span class="nf">get</span> <span class="ow">::</span> <span class="kt">IVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="n">a</span>
</pre>


<ul>
<li>
<code>IVar</code> -- as a box that stars empty</li>
<li>
<code>put</code> -- store a value in the box <ul>
<li>All values communicated through IVars are fully evaluated. There is a head-strict version <code>put_</code> </li>
</ul>
</li>
<li>
<code>get</code> -- read the value. If the box is empty, it waits until the box is filled
  by put. The <code>get</code> operation does not remove the value from the box. Once the
  box is full. It stays the state constantly.</li>
</ul>
<hr>
<h4>Par Monad</h4>
<ul>
<li>Example </li>
</ul>
<pre class="code literal-block"><span class="nf">runPar</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">i</span> <span class="ow">&lt;-</span> <span class="n">new</span>
    <span class="n">j</span> <span class="ow">&lt;-</span> <span class="n">new</span>
    <span class="n">fork</span> <span class="p">(</span><span class="n">put</span> <span class="n">i</span> <span class="p">(</span><span class="n">fib</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">fork</span> <span class="p">(</span><span class="n">put</span> <span class="n">j</span> <span class="p">(</span><span class="n">fib</span> <span class="n">m</span><span class="p">))</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">get</span> <span class="n">i</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">get</span> <span class="n">j</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
</pre>


<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/24606632@N05/25642271873/in/dateposted-public/" title="par_monad"><img src="https://farm2.staticflickr.com/1609/25642271873_74a6b5c51e_c.jpg" width="800" height="230" alt="par_monad"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
<hr>
<h4>Par Monad</h4>
<ul>
<li>
<code>spawn</code> - Like fork, but returns a IVar that can be used to query the result
    of the forked computation. Therefore spawn provides <strong>futures</strong> or
    <strong>promises</strong>.</li>
<li>
<code>parMap</code> - parallel version map implemented with par monad</li>
</ul>
<!-- Yen3: need to review how to use `spawn` individually.  --><pre class="code literal-block"><span class="nf">spawn</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Par</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="p">(</span><span class="kt">IVar</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">spawn</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">i</span> <span class="ow">&lt;-</span> <span class="n">new</span>
    <span class="n">fork</span> <span class="p">(</span><span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">p</span><span class="p">;</span> <span class="n">put</span> <span class="n">i</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">return</span> <span class="n">i</span>

<span class="nf">parMap</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">parMap</span> <span class="n">f</span> <span class="n">as</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">ibs</span> <span class="ow">&lt;-</span> <span class="n">mapM</span> <span class="p">(</span><span class="n">spawn</span> <span class="o">.</span> <span class="n">return</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span> <span class="n">as</span>
    <span class="n">mapM</span> <span class="n">get</span> <span class="n">ibs</span>
</pre>


<!--
f :: a -> b
return . f :: a -> m b
spawn . return . f :: a -> Par (IVar a)
-->

<hr>
<h4>Example - prime number</h4>
<ul>
<li>Example<ul>
<li>
<code>primeIntVector</code> - Eval monad </li>
<li>
<code>primeIntVector'</code> - Par monad </li>
</ul>
</li>
</ul>
<pre class="code literal-block"><span class="nf">primeIntVector</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">VU</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Int</span>
<span class="nf">primeIntVector</span> <span class="n">n</span> <span class="ow">=</span>
    <span class="kr">let</span>
        <span class="n">ls</span> <span class="ow">=</span> <span class="n">genNumberRange</span> <span class="mi">0</span> <span class="n">n</span> <span class="mi">100</span>
    <span class="kr">in</span>
        <span class="kt">VU</span><span class="o">.</span><span class="n">concat</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="n">uncurry</span> <span class="n">primes</span><span class="p">)</span> <span class="n">ls</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">rseq</span><span class="p">)</span>


<span class="nf">primeIntVector'</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">VU</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Int</span>
<span class="nf">primeIntVector'</span> <span class="n">n</span> <span class="ow">=</span>
    <span class="kr">let</span>
        <span class="n">ls</span> <span class="ow">=</span> <span class="n">genNumberRange</span> <span class="mi">0</span> <span class="n">n</span> <span class="mi">100</span>
    <span class="kr">in</span>
        <span class="kt">VU</span><span class="o">.</span><span class="n">concat</span> <span class="o">$</span> <span class="kt">Par</span><span class="o">.</span><span class="n">runPar</span> <span class="o">$</span> <span class="kt">Par</span><span class="o">.</span><span class="n">parMap</span> <span class="p">(</span><span class="n">uncurry</span> <span class="n">primes</span><span class="p">)</span> <span class="n">ls</span>
</pre>


<hr>
<h4>Difference between <code>Par</code> and <code>Eval</code>
</h4>
<ul>
<li>Par Monad <ol>
<li>Always evaluate its value to normal form. It avoids the problem
   about the weak-normal form</li>
<li>The cost of calling <code>runPar</code> function is bigger then <code>runEval</code> </li>
<li>Easy to redefine the scheduling strategy</li>
</ol>
</li>
</ul>
<hr>
<h4>Difference between <code>Par</code> and <code>Eval</code>
</h4>
<ul>
<li>
<p>Eval Monad</p>
<ol>
<li>Need use <code>force</code> function to evaluate its value from weak-head normal
   form to normal form. It’s suitable for lazy data structure</li>
<li>The cost of calling <code>runEval</code> function is free</li>
<li>Provide the speculative parallelism </li>
<li>Eval Monad has more diagnostics in ThreadScope compared Par Monad.</li>
</ol>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/23326920/difference-between-par-monad-and-eval-monad-with-deepseq">Reference</a></p>
</li>
</ul>
<!--- What’s the pitfall of Eval Monad ? --><!--- What’s the pitfall of Par Monad ?--><hr>
<h4>Repa</h4>
<ul>
<li>Repa - REgular PArallel arrays</li>
<li>
<strong>Goal</strong><ul>
<li>efficient numerical array computations in Haskell and run them in
  parallel </li>
</ul>
</li>
<li>It could provides efficient unboxed data computation, but not Par monad and
  Strategy monad   <ul>
<li>Repa also support boxed data.</li>
</ul>
</li>
</ul>
<hr>
<h4>Repa - type</h4>
<ul>
<li>The array type</li>
</ul>
<pre class="code literal-block"><span class="kr">data</span> <span class="kt">Array</span> <span class="n">r</span> <span class="n">sh</span> <span class="n">e</span>
</pre>


<ul>
<li>
<code>r</code> -  representation type </li>
<li>
<code>e</code> - element type </li>
<li>
<code>sh</code> - the shape of array (the dimension(s) of array)</li>
</ul>
<pre class="code literal-block"><span class="kr">data</span> <span class="kt">Z</span> <span class="ow">=</span> <span class="kt">Z</span>    <span class="c1">-- scalar data</span>
<span class="kr">data</span> <span class="n">tail</span> <span class="kt">:.</span> <span class="n">head</span> <span class="ow">=</span> <span class="n">tail</span> <span class="kt">:.</span> <span class="n">head</span>

<span class="kr">type</span> <span class="kt">DIM0</span> <span class="ow">=</span> <span class="kt">Z</span>
<span class="kr">type</span> <span class="kt">DIM1</span> <span class="ow">=</span> <span class="kt">DIM0</span> <span class="kt">:.</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kt">DIM2</span> <span class="ow">=</span> <span class="kt">DIM1</span> <span class="kt">:.</span> <span class="kt">Int</span>
</pre>


<hr>
<h4>Repa - array</h4>
<ul>
<li>how to create an array with <code>Array</code> type ?<ul>
<li>
<code>fromListUnboxed</code> - from list of unboxed type</li>
<li>
<code>fromUnboxed</code> - from the vector with <code>Data.Vector.Unboxed</code> type</li>
<li>
<code>fromFunction</code> - from the shape information to generate the array</li>
<li>... etc</li>
</ul>
</li>
</ul>
<pre class="code literal-block"><span class="nf">fromListUnboxed</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Shape</span> <span class="n">sh</span><span class="p">,</span> <span class="kt">Unbox</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">sh</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="n">sh</span> <span class="n">a</span>
<span class="nf">fromFunction</span> <span class="ow">::</span> <span class="n">sh</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">sh</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">D</span> <span class="n">sh</span> <span class="n">a</span>
<span class="nf">fromUnboxed</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Shape</span> <span class="n">sh</span><span class="p">,</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Vector</span><span class="o">.</span><span class="kt">Unboxed</span> <span class="n">e</span><span class="p">)</span> <span class="ow">::</span> <span class="n">sh</span> <span class="ow">-&gt;</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="n">sh</span> <span class="n">e</span>
</pre>


<!-- 
the major difference between `fromListUnboxed` and `fromUnboxed`
   - `fromListUnboxed` - O(n). Convert a list to an unboxed vector array.
   - `fromUnboxed` - O(1). Wrap an unboxed vector as an array. 
-->

<hr>
<h4>Repa - create array example</h4>
<ul>
<li>Example - create an array</li>
</ul>
<pre class="code literal-block"><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Data.Array.Repa</span> <span class="k">as</span> <span class="n">R</span>
<span class="kt">Prelude</span> <span class="kt">R</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">R</span><span class="o">.</span><span class="n">fromListUnboxed</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="mi">10</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="ow">::</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="kt">DIM1</span> <span class="kt">Int</span>
<span class="kt">Prelude</span> <span class="kt">R</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">a</span> 
<span class="nf">a</span> <span class="ow">::</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="kt">DIM1</span> <span class="kt">Int</span>

<span class="kt">Prelude</span> <span class="kt">R</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">b</span> <span class="ow">=</span>  <span class="kt">R</span><span class="o">.</span><span class="n">fromFunction</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="n">i</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>
<span class="kt">Prelude</span> <span class="kt">R</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">b</span>
<span class="nf">b</span> <span class="ow">::</span> <span class="kt">Array</span> <span class="kt">D</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="kt">Int</span><span class="p">)</span> <span class="kt">Int</span>

<span class="kt">Prelude</span> <span class="kt">R</span> <span class="o">&gt;</span> <span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Vector.Unboxed</span> <span class="k">as</span> <span class="n">VU</span>
<span class="kt">Prelude</span> <span class="kt">R</span> <span class="kt">VU</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">VU</span><span class="o">.</span><span class="n">enumFromN</span> <span class="mi">1</span> <span class="mi">10</span> <span class="ow">::</span> <span class="kt">VU</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Int</span>
<span class="kt">Prelude</span> <span class="kt">R</span> <span class="kt">VU</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">c</span> <span class="ow">=</span> <span class="kt">R</span><span class="o">.</span><span class="n">fromUnboxed</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="p">(</span><span class="kt">VU</span><span class="o">.</span><span class="n">length</span> <span class="n">v</span><span class="p">))</span> <span class="n">v</span>
<span class="kt">Prelude</span> <span class="kt">R</span> <span class="kt">VU</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">c</span>
<span class="nf">c</span> <span class="ow">::</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="kt">Int</span><span class="p">)</span> <span class="kt">Int</span>
</pre>


<hr>
<h4>Repa - array computation</h4>
<ul>
<li>All array will transfer to a delayed array type (ex: <code>Array D sh e</code>)
  after array computations (ex: <code>Repa.map</code>)</li>
</ul>
<pre class="code literal-block"><span class="kt">Repa</span><span class="o">.</span><span class="n">map</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Shape</span> <span class="n">sh</span><span class="p">,</span> <span class="kt">Source</span> <span class="n">r</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span>
     <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">r</span> <span class="n">sh</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">D</span> <span class="n">sh</span> <span class="n">b</span>

<span class="p">(</span><span class="o">+^</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Shape</span> <span class="n">sh</span><span class="p">,</span> <span class="kt">Source</span> <span class="n">r1</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Source</span> <span class="n">r2</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span>
     <span class="kt">Array</span> <span class="n">r1</span> <span class="n">sh</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">r2</span> <span class="n">sh</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">D</span> <span class="n">sh</span> <span class="n">c</span>
</pre>


<hr>
<h4>Repa - compute</h4>
<ul>
<li>
<code>computeS</code> - calculate the array operations in sequentially.</li>
<li>
<code>computeP</code> - the same as <code>computeS</code> but in parallel.<ul>
<li>the purpose of the monad is only to ensure that <code>computeP</code> operations are
  performed in sequence and not nested.<ul>
<li>the simplest way to reduce the monad effect -- <code>runIdentity</code>
</li>
<li>See page p.94 to get more information</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="code literal-block"><span class="nf">computeS</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Load</span> <span class="n">r1</span> <span class="n">sh</span> <span class="n">e</span><span class="p">,</span> <span class="kt">Target</span> <span class="n">r2</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Array</span> <span class="n">r1</span> <span class="n">sh</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">r2</span> <span class="n">sh</span> <span class="n">e</span>
<span class="nf">computeP</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Source</span> <span class="n">r2</span> <span class="n">e</span><span class="p">,</span> <span class="kt">Target</span> <span class="n">r2</span> <span class="n">e</span><span class="p">,</span> <span class="kt">Load</span> <span class="n">r1</span> <span class="n">sh</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span>
    <span class="kt">Array</span> <span class="n">r1</span> <span class="n">sh</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Array</span> <span class="n">r2</span> <span class="n">sh</span> <span class="n">e</span><span class="p">)</span>
</pre>


<hr>
<h4>Repa - array computation example</h4>
<ul>
<li>calculate $e^x = \sum^{\infty}_{n=0}\frac{x^n}{n!} \forall x$</li>
</ul>
<pre class="code literal-block"><span class="kr">import</span> <span class="nn">Data.Array.Repa</span> <span class="k">as</span> <span class="n">R</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Identity</span>

<span class="nf">fact</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="p">]</span>

<span class="nf">enumN</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">D</span> <span class="kt">DIM1</span> <span class="kt">Double</span>
<span class="nf">enumN</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">R</span><span class="o">.</span><span class="n">fromFunction</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="n">i</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">fromIntegral</span> <span class="n">i</span><span class="p">)</span>  

<span class="nf">exp'</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">exp'</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">let</span>
             <span class="n">ns</span> <span class="ow">=</span> <span class="n">enumN</span> <span class="mi">100</span>
             <span class="n">ys</span> <span class="ow">=</span> <span class="kt">R</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">n</span> <span class="ow">-&gt;</span> <span class="p">(((</span><span class="n">fromIntegral</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fact</span> <span class="n">n</span><span class="p">)))</span>
                  <span class="n">ns</span> 
         <span class="kr">in</span>
             <span class="n">runIdentity</span> <span class="o">.</span> <span class="kt">R</span><span class="o">.</span><span class="n">sumAllP</span> <span class="o">$</span> <span class="n">ys</span>
</pre>


wzxhzdk:32

--&gt;

<hr>
<h4>Repa - example</h4>
<ul>
<li>Example - prime numbers</li>
</ul>
<pre class="code literal-block"><span class="nf">primeArray</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">VU</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Int</span>
<span class="nf">primeArray</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">let</span>
                   <span class="n">a</span> <span class="ow">=</span> <span class="n">genArray</span> <span class="n">n</span>
                   <span class="n">ps</span> <span class="ow">=</span> <span class="n">runIdentity</span> <span class="o">.</span> <span class="kt">Repa</span><span class="o">.</span><span class="n">computeUnboxedP</span> <span class="o">.</span> <span class="n">primeArrayCheck</span> <span class="o">$</span>
                        <span class="n">a</span> <span class="ow">::</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="kt">DIM1</span> <span class="kt">Int</span>
               <span class="kr">in</span>
                   <span class="kt">VU</span><span class="o">.</span><span class="n">filter</span> <span class="p">(</span><span class="o">/=</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Repa</span><span class="o">.</span><span class="n">toUnboxed</span> <span class="n">ps</span><span class="p">)</span>
</pre>


<hr>
<h4>Conclusion</h4>
<ul>
<li>
<p>The simplest parallel method - parallel map</p>
<ul>
<li>use <code>parMap</code> or <code>parList</code>
</li>
</ul>
</li>
<li>
<p>Repa is useful especially for numeric calculation.</p>
</li>
<li>
<p>The remaining part of <a href="http://chimera.labs.oreilly.com/books/1230000000929">the book</a>
  is about.</p>
<ul>
<li>Parallel programming with GPU (<a href="https://hackage.haskell.org/package/accelerate"><code>Data.Accelerate</code></a>)</li>
<li>Concurrent programming</li>
</ul>
</li>
<li>
<p>Bool unbxoed type ?</p>
</li>
</ul>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../categories/all/" rel="tag">all</a></li>
            <li><a class="tag p-category" href="../../../categories/haskell/" rel="tag">haskell</a></li>
            <li><a class="tag p-category" href="../../../categories/note/" rel="tag">note</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../../2015/20151227_murmur-text-file-format/" rel="prev" title="murmur (10) - mkd &amp; LaTeX">Previous post</a>
            </li>
            <li class="next">
                <a href="../20160621_instasll-agda-in-mac-osx/" rel="next" title="Instasll agda in Mac OSX">Next post</a>
            </li>
        </ul></nav></aside><section class="comments"><h2>Comments</h2>
        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="yen3snote",
            disqus_url="https://yen3.github.io/posts/2016/20160405_a-primer-s-note-for-parallel-programming-in-haskell/",
        disqus_title="A primer's note for parallel programming in Haskell",
        disqus_identifier="cache/posts/2016/20160405_a-primer-s-note-for-parallel-programming-in-haskell.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section></article><script>var disqus_shortname="yen3snote";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
    
    <div class="footer-wrapper">
        <footer role="contentinfo"><p>Contents © 2016         <a href="mailto:yen3rc@gmail.com">Yen3</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>

    
    
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script><script src="../../../assets/js/scripts.min.js"></script>
</body>
</html>
