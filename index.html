<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]--><!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]--><!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]--><!--[if gt IE 8]><!--><!--<![endif]--><head>
<meta charset="utf-8">
<meta name="description" content="Let's see how far we can go.">
<!-- http://t.co/dKP3o1e --><meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Yen3's note | Yen3's note</title>
<link href="assets/css/rst.css" rel="stylesheet" type="text/css">
<link href="assets/css/code.css" rel="stylesheet" type="text/css">
<link href="assets/css/main.css" rel="stylesheet" type="text/css">
<link href="assets/css/extra.css" rel="stylesheet" type="text/css">
<!-- Webfonts --><link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">
<!-- Load Modernizr --><script src="//mmistakes.github.io/hpstr-jekyll-theme/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script><link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="https://yen3.github.io/">
<link rel="next" href="index-5.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><link rel="prefetch" href="posts/2016/20160621_instasll-agda-in-mac-osx/" type="text/html">
</head>
<body id="post-index" class="feature">
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    

    <nav id="dl-menu" class="dl-menuwrapper" role="navigation"><button class="dl-trigger">Open Menu</button>
    <ul class="dl-menu">
<li><a href="archive.html">Archive</a></li>
            <li><a href="categories/">Tags</a></li>
            <li><a href="rss.xml">RSS feed</a></li>
    
    
    </ul></nav><div class="entry-header">
<!-- FIXME: get credit from settings -->
    <div class="entry-image"> --&gt;
    </div>
<!-- /.entry-image --> 
      
  <div class="header-title">
    <div class="header-title-wrap">
    <h1 id="brand"><a href="https://yen3.github.io/" title="Yen3's note" rel="home">
    Yen3's note</a></h1>
     <!--<h2>Yen3's note</h2>-->
    </div>
<!-- /.header-title-wrap -->
  </div>
<!-- /.header-title -->

</div>
<!-- /.entry-header -->

    <div id="main" role="main">
            

    <article class="hentry"><header><div class="entry-meta">
      <span class="entry-date date published updated">
        <time datetime="2016-06-21T07:45:53+08:00" title="2016-06-21 07:45">2016-06-21 07:45</time></span>  ·  
      <span class="byline author vcard">Yen3</span>
            ·  <span class="commentline">
        
    <a href="posts/2016/20160621_instasll-agda-in-mac-osx/#disqus_thread" data-disqus-identifier="cache/posts/2016/20160621_instasll-agda-in-mac-osx.html">Comments</a>


      </span>
</div>
        <h1 class="p-name entry-title"><a href="posts/2016/20160621_instasll-agda-in-mac-osx/" class="u-url">Instasll agda in Mac OSX</a></h1>
    </header><div class="e-content entry-content">
    <div>
<p>做個備忘</p>
<pre class="code literal-block">brew install ghc cabal-install
cabal install happy
cabal install alex
cabal install agda
</pre>
</div>
    </div>
    </article><article class="hentry"><header><div class="entry-meta">
      <span class="entry-date date published updated">
        <time datetime="2016-04-05T11:57:05+08:00" title="2016-04-05 11:57">2016-04-05 11:57</time></span>  ·  
      <span class="byline author vcard">Yen3</span>
            ·  <span class="commentline">
        
    <a href="posts/2016/20160405_a-primer-s-note-for-parallel-programming-in-haskell/#disqus_thread" data-disqus-identifier="cache/posts/2016/20160405_a-primer-s-note-for-parallel-programming-in-haskell.html">Comments</a>


      </span>
</div>
        <h1 class="p-name entry-title"><a href="posts/2016/20160405_a-primer-s-note-for-parallel-programming-in-haskell/" class="u-url">A primer's note for parallel programming in Haskell</a></h1>
    </header><div class="e-content entry-content">
    <div>
<ul>
<li>Functional Thursday #33</li>
<li>2015.12.03</li>
<li>Yen3 (yen3rc@gmail.com)</li>
</ul>
<hr>
<h4>About the slide</h4>
<ul>
<li>
<p>這份投影片是 <a href="http://chimera.labs.oreilly.com/books/1230000000929">Parallel and Concurrent Programming in Haskell</a> -
  Chatper 1 ~ 5 的筆記</p>
</li>
<li>
<p>主題包含 </p>
<ul>
<li>Eval monad </li>
<li>Par monad</li>
<li>Repa</li>
</ul>
</li>
<li>
<p>今天的內容皆與 data-level parallelism 相關 </p>
</li>
<li>在 Haskell 中，一個較容易平行化 function 是 <code>map</code>，這份投影片會很常
  討論到它。</li>
</ul>
<hr>
<h4>Definition of Parallel</h4>
<ul>
<li>A <strong>parallel</strong> program is one that uses a multiplicity of computational
  hardware (e.g., several processor cores) to perform a computation more
  quickly.</li>
<li>Parallel programming in Haskell is deterministic: The parallel program always
  produces the same answer, regardless of how many processors are used to run
  it.</li>
</ul>
<!-------><!--## Self-study --><!--- 在進入正題之前，先談幾個小筆記--><!--- Normal form, weak-head normal form and `force` function--><!--- unboxed type & boxed type--><!--- Bang patterns--><!--- Data.Vector package--><hr>
<h4>The status of value in ghc (1/)</h4>
<ul>
<li>There are three conditions of a value.<ul>
<li>Unevaluated </li>
<li>Weak-Head Normal Form (WHNF) - evaluated with first constructor</li>
<li>Normal Form (NF) - fully evaluated</li>
</ul>
</li>
</ul>
<hr>
<h4>The status of value in ghc (2/)</h4>
<ul>
<li>
<code>sprint</code> - prints a value without forcing its evaluation</li>
<li>
<code>seq</code>: only far as the first constructor and doesn't evaluate any more of
  the structure. It evaluates first argument to WHNF.</li>
</ul>
<pre class="code literal-block"><span class="nf">seq</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre>


<hr>
<h4>The status of value in ghc (3/)</h4>
<ul>
<li>Example </li>
</ul>
<pre class="code literal-block"><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">x</span>
<span class="nf">x</span> <span class="ow">=</span> <span class="kr">_</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">y</span>
<span class="nf">y</span> <span class="ow">=</span> <span class="kr">_</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">seq</span> <span class="n">y</span> <span class="nb">()</span>
<span class="nb">()</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">x</span>
<span class="nf">x</span> <span class="ow">=</span> <span class="mi">3</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">y</span>
<span class="nf">y</span> <span class="ow">=</span> <span class="mi">4</span>
</pre>


<hr>
<h4>The status of value in ghc (4/)</h4>
<pre class="code literal-block"><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">xs</span>
<span class="nf">xs</span> <span class="ow">=</span> <span class="kr">_</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">seq</span> <span class="n">xs</span> <span class="nb">()</span>
<span class="nb">()</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">xs</span>
<span class="nf">xs</span> <span class="ow">=</span> <span class="kr">_</span> <span class="kt">:</span> <span class="kr">_</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">length</span> <span class="n">xs</span>
<span class="mi">10</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">xs</span>
<span class="nf">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">]</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="n">xs</span>
<span class="mi">65</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">sprint</span> <span class="n">xs</span>
<span class="nf">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
</pre>


<hr>
<h4>
<code>force</code> function</h4>
<ul>
<li>
<code>force</code> - fully evaluated it's argument and returns it. (WHNF into NF)</li>
</ul>
<pre class="code literal-block"><span class="kr">import</span> <span class="nn">Control.DeepSeq</span>

<span class="kr">class</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">rnf</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="nb">()</span>      <span class="c1">-- reduce to normal-form</span>
    <span class="n">rnf</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="nb">()</span>

<span class="nf">deepseq</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">deepseq</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">rnf</span> <span class="n">a</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">b</span> 

<span class="nf">force</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>   
<span class="nf">force</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">deepseq</span><span class="p">`</span> <span class="n">x</span>
</pre>


<ul>
<li>
<code>seq</code>: only far as the first constructor and doesn't evaluate any more of
  the structure. It evaluates first argument to WHNF.</li>
</ul>
<!-- deepseq: fully evaluates its argument and then returns () --><hr>
<h4>Eval monad</h4>
<ul>
<li>Decoupling of the algorithm from the parallelism</li>
<li>The type declaration for eval monad </li>
</ul>
<pre class="code literal-block"><span class="kr">data</span> <span class="kt">Eval</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Eval</span>

<span class="nf">runEval</span> <span class="ow">::</span> <span class="kt">Eval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">rpar</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="n">a</span>   <span class="c1">-- rpar :: Strategy a </span>
<span class="nf">rseq</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="n">a</span>   <span class="c1">-- rseq :: Strategy a</span>
</pre>


<ul>
<li>
<code>rpar</code> - evaluate its argument in parallel.</li>
<li>
<code>rseq</code> - Evaluate the argument and wait for the result.<ul>
<li>evaluates its argument to WHNF.</li>
</ul>
</li>
</ul>
<!--
- The argument of `rpar` is also named **spark**.
--><hr>
<h4>Eval monad - simple example</h4>
<ul>
<li>Example</li>
</ul>
<pre class="code literal-block"><span class="nf">runEval</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">rseq</span> <span class="p">(</span><span class="n">f</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">rseq</span> <span class="n">a</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre>


<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/24606632@N05/26219016196/in/dateposted-public/" title="eval_monad_simple_example"><img src="https://farm2.staticflickr.com/1717/26219016196_6d47d9e102.jpg" width="800" height="328" alt="eval_monad_simple_example"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
<hr>
<h4>Eval monad - Strategy</h4>
<ul>
<li>Strategy - modularize parllel code by separating the algorithm from the
  parallelism <ul>
<li>use <code>using</code> function to add parallelism with the existing codes</li>
<li>
<code>withStrategy</code>- a another version of <code>using</code> with the arguments flipped</li>
</ul>
</li>
</ul>
<pre class="code literal-block"><span class="kr">type</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Eval</span> <span class="n">a</span>

<span class="nf">using</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">x</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">runEval</span> <span class="p">(</span><span class="n">s</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">withStrategy</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">withStrategy</span> <span class="n">s</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">runEval</span> <span class="p">(</span><span class="n">s</span> <span class="n">x</span><span class="p">)</span>
</pre>


<hr>
<h4>Eval monad - Strategy</h4>
<ul>
<li>The <code>rpar</code>, <code>rseq</code> are also Strategies.</li>
</ul>
<pre class="code literal-block"><span class="nf">rpar</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span>
<span class="nf">rseq</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span>
</pre>


<ul>
<li>You could write the algorithm first and add the parallelism code later
  ideally.</li>
</ul>
<hr>
<h4>Eval monad - example for pair</h4>
<ul>
<li>Example</li>
</ul>
<pre class="code literal-block"><span class="kr">import</span> <span class="nn">Control.Parallel.Strategies</span>
<span class="kr">import</span> <span class="nn">Control.DeepSeq</span>

<span class="nf">evalPair</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="nf">evalPair</span> <span class="n">sa</span> <span class="n">sb</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a'</span> <span class="ow">&lt;-</span> <span class="n">sa</span> <span class="n">a</span>
    <span class="n">b'</span> <span class="ow">&lt;-</span> <span class="n">sb</span> <span class="n">b</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a'</span><span class="p">,</span><span class="n">b'</span><span class="p">)</span>
</pre>


<hr>
<h4>Eval monad - example for pair</h4>
<pre class="code literal-block"><span class="nf">rparWith</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span>
<span class="nf">rparWith</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span>
    <span class="kr">do</span>
        <span class="n">ra</span> <span class="ow">&lt;-</span> <span class="n">rpar</span> <span class="n">a</span>
        <span class="n">sa</span> <span class="ow">&lt;-</span> <span class="n">s</span> <span class="n">ra</span>
        <span class="n">return</span> <span class="n">sa</span> 

<span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span>             <span class="c1">-- (1-1)  </span>
<span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1">-- (1-2)</span>

<span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">rpar</span>   <span class="c1">-- (2-1)</span>
<span class="o">&lt;!--</span><span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">evalPair</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">rseq</span><span class="p">)</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">rseq</span><span class="p">)</span>  <span class="c1">-- (2-2)--&gt;</span>
<span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">evalPair</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">rseq</span><span class="p">)</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">rseq</span><span class="p">)</span>  <span class="c1">-- (2-2)</span>
</pre>


<ul>
<li>(1-1), (1-2) - sequential version</li>
<li>(2-1), (2-2) - parallel version and reduce the value to WHNF</li>
</ul>
wzxhzdk:10


- (3-1), (3-2) - parallel version and reduce the value to NF 
- `parTuple2` and `evalPair` functions are the same
--&gt;

<hr>
<h4>Eval monad - some help functions (1/)</h4>
<ul>
<li>About some helper function<ul>
<li>
<code>rdeepseq</code> - evaluates the argument to NF </li>
</ul>
</li>
</ul>
<pre class="code literal-block"><span class="nf">rdeepseq</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span>
<span class="nf">rdeepseq</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">rseq</span> <span class="p">(</span><span class="n">force</span> <span class="n">x</span><span class="p">)</span>
</pre>


<pre class="code literal-block">- `rparWith` - wraps the Strategy s in an `rpar`
</pre>


<pre class="code literal-block"><span class="nf">rparWith</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="n">a</span> 
</pre>


<hr>
<h4>Eval monad - some help functions (2/)</h4>
<ul>
<li>The code reduced to NF in previous slide could also be written as </li>
</ul>
<pre class="code literal-block"><span class="c1">-- NF </span>
<span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">rparWith</span> <span class="n">rdeepseq</span> 
<span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span>
    <span class="n">evalPair</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">rdeepseq</span><span class="p">)</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">rdeepseq</span><span class="p">)</span>
</pre>


<hr>
<h4>Eval monad - parallelize <code>map</code>
</h4>
<pre class="code literal-block"><span class="nf">parMap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">parMap</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">f</span> <span class="n">x</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">rseq</span> 

<span class="nf">evalList</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">evalList</span> <span class="n">start</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">[]</span>
<span class="nf">evalList</span> <span class="n">start</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x'</span> <span class="ow">&lt;-</span> <span class="n">start</span> <span class="n">x</span>
    <span class="n">xs'</span> <span class="ow">&lt;-</span> <span class="n">evalList</span> <span class="n">start</span> <span class="n">xs</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">x'</span><span class="kt">:</span> <span class="n">xs'</span><span class="p">)</span>

<span class="nf">parList</span> <span class="ow">::</span> <span class="kt">Strategy</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Strategy</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">parList</span> <span class="n">start</span> <span class="ow">=</span> <span class="n">evalList</span> <span class="p">(</span><span class="n">rparWith</span> <span class="n">start</span><span class="p">)</span>
</pre>


<ul>
<li>
<code>parMap</code> will calculate its list to WHNF</li>
<li>
<code>parList</code> - evaluate the list element in parallel </li>
</ul>
<hr>
<h4>Eval monad</h4>
<ul>
<li>Example</li>
</ul>
<pre class="code literal-block"><span class="kr">import</span> <span class="nn">Control.Parallel.Strategies</span>
<span class="kr">import</span> <span class="nn">Control.DeepSeq</span>

<span class="nf">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>  <span class="c1">-- (1) </span>
<span class="nf">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">rseq</span> <span class="c1">-- (2)</span>
<span class="nf">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">rdeepseq</span>  <span class="c1">-- (3)</span>
</pre>


<ul>
<li>(1) sequential version</li>
<li>(2) parallelize version reduce value to WHNF</li>
<li>(3) parallelize version reduce value to NF </li>
</ul>
<hr>
<h4>Example - Mandelbrot set</h4>
<ul>
<li>
<p>You could get more details
  from <a href="https://yen3.github.io/posts/2015/20150625_haskell-practice-mandelbrot-binary/">my blog post</a>.</p>
</li>
<li>
<p>some type define</p>
</li>
</ul>
<pre class="code literal-block"><span class="kr">type</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">Range</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">Plane</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Range</span><span class="p">,</span> <span class="kt">Range</span><span class="p">)</span>
</pre>


<ul>
<li>sequential version</li>
</ul>
<pre class="code literal-block"><span class="nf">planePoints</span> <span class="ow">::</span> <span class="kt">Plane</span> <span class="ow">-&gt;</span> <span class="kt">V</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Point</span>

<span class="nf">mandelSet</span> <span class="ow">::</span> <span class="kt">Plane</span> <span class="ow">-&gt;</span> <span class="kt">V</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Point</span>
<span class="nf">mandelSet</span> <span class="ow">=</span> <span class="n">planeToMandelPoints</span>
</pre>


<hr>
<h4>Example - Mandelbrot set</h4>
<ul>
<li>basic parallel version with <code>parList</code>
</li>
</ul>
<pre class="code literal-block"><span class="nf">splitPlane</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Plane</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Plane</span><span class="p">]</span>

<span class="nf">mandelSetStart</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Plane</span> <span class="ow">-&gt;</span> <span class="kt">V</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Point</span>
<span class="nf">mandelSetStart</span> <span class="n">size</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">V</span><span class="o">.</span><span class="n">concat</span>
    <span class="p">(</span><span class="n">map</span> <span class="n">planeToMandelPoints</span> <span class="p">(</span><span class="n">splitPlane</span> <span class="n">size</span> <span class="n">p</span><span class="p">)</span>
     <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">rseq</span><span class="p">)</span>
</pre>


<ul>
<li>In  2010 late MBP15 (Intel Core i5 2.4 Ghz, 8Gb)<ul>
<li>sequential - about 45 secs</li>
<li>run in 2 cores - about 25 secs (<code>./Mandelbrot par 100 +RTS -N2 -s</code>)</li>
</ul>
</li>
</ul>
<hr>
<h4>Par Monad</h4>
<ul>
<li>
<strong>Goal</strong><ul>
<li>be more explicit about granularity and data dependences </li>
<li>Avoid the reliance on lazy evaluation, but without sacrificing the
  determinism that we value for parallel programming.</li>
<li>The parallel computations are pure (and deterministic)</li>
</ul>
</li>
<li>The library is implemented entirely as a Haskell library<ul>
<li>You can accommodate alternative scheduling strategies.</li>
</ul>
</li>
</ul>
<hr>
<h4>Par Monad</h4>
<ul>
<li>Par monad - a monad for parallel computation </li>
</ul>
<pre class="code literal-block"><span class="kr">newtype</span> <span class="kt">Par</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Par</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Par</span>

<span class="nf">runPar</span> <span class="ow">::</span> <span class="kt">Par</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>    <span class="c1">-- produce a pure result.</span>
<span class="nf">fork</span> <span class="ow">::</span> <span class="kt">Par</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="nb">()</span> <span class="c1">-- the way to create parallel tasks</span>
</pre>


<ul>
<li>IVar - results are communicated through IVars</li>
</ul>
<pre class="code literal-block"><span class="kr">data</span> <span class="kt">IVar</span> <span class="n">a</span> 

<span class="nf">new</span> <span class="ow">::</span> <span class="kt">Par</span> <span class="p">(</span><span class="kt">IVar</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">put</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">IVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="nb">()</span>
<span class="nf">get</span> <span class="ow">::</span> <span class="kt">IVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="n">a</span>
</pre>


<hr>
<h4>Par Monad</h4>
<ul>
<li>IVar</li>
</ul>
<pre class="code literal-block"><span class="kr">data</span> <span class="kt">IVar</span> <span class="n">a</span> 

<span class="nf">new</span> <span class="ow">::</span> <span class="kt">Par</span> <span class="p">(</span><span class="kt">IVar</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">put</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">IVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="nb">()</span>
<span class="nf">get</span> <span class="ow">::</span> <span class="kt">IVar</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="n">a</span>
</pre>


<ul>
<li>
<code>IVar</code> -- as a box that stars empty</li>
<li>
<code>put</code> -- store a value in the box <ul>
<li>All values communicated through IVars are fully evaluated. There is a head-strict version <code>put_</code> </li>
</ul>
</li>
<li>
<code>get</code> -- read the value. If the box is empty, it waits until the box is filled
  by put. The <code>get</code> operation does not remove the value from the box. Once the
  box is full. It stays the state constantly.</li>
</ul>
<hr>
<h4>Par Monad</h4>
<ul>
<li>Example </li>
</ul>
<pre class="code literal-block"><span class="nf">runPar</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">i</span> <span class="ow">&lt;-</span> <span class="n">new</span>
    <span class="n">j</span> <span class="ow">&lt;-</span> <span class="n">new</span>
    <span class="n">fork</span> <span class="p">(</span><span class="n">put</span> <span class="n">i</span> <span class="p">(</span><span class="n">fib</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">fork</span> <span class="p">(</span><span class="n">put</span> <span class="n">j</span> <span class="p">(</span><span class="n">fib</span> <span class="n">m</span><span class="p">))</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">get</span> <span class="n">i</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">get</span> <span class="n">j</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
</pre>


<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/24606632@N05/25642271873/in/dateposted-public/" title="par_monad"><img src="https://farm2.staticflickr.com/1609/25642271873_74a6b5c51e_c.jpg" width="800" height="230" alt="par_monad"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
<hr>
<h4>Par Monad</h4>
<ul>
<li>
<code>spawn</code> - Like fork, but returns a IVar that can be used to query the result
    of the forked computation. Therefore spawn provides <strong>futures</strong> or
    <strong>promises</strong>.</li>
<li>
<code>parMap</code> - parallel version map implemented with par monad</li>
</ul>
<!-- Yen3: need to review how to use `spawn` individually.  --><pre class="code literal-block"><span class="nf">spawn</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Par</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="p">(</span><span class="kt">IVar</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">spawn</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">i</span> <span class="ow">&lt;-</span> <span class="n">new</span>
    <span class="n">fork</span> <span class="p">(</span><span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">p</span><span class="p">;</span> <span class="n">put</span> <span class="n">i</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">return</span> <span class="n">i</span>

<span class="nf">parMap</span> <span class="ow">::</span> <span class="kt">NFData</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Par</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">parMap</span> <span class="n">f</span> <span class="n">as</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">ibs</span> <span class="ow">&lt;-</span> <span class="n">mapM</span> <span class="p">(</span><span class="n">spawn</span> <span class="o">.</span> <span class="n">return</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span> <span class="n">as</span>
    <span class="n">mapM</span> <span class="n">get</span> <span class="n">ibs</span>
</pre>


<!--
f :: a -> b
return . f :: a -> m b
spawn . return . f :: a -> Par (IVar a)
-->

<hr>
<h4>Example - prime number</h4>
<ul>
<li>Example<ul>
<li>
<code>primeIntVector</code> - Eval monad </li>
<li>
<code>primeIntVector'</code> - Par monad </li>
</ul>
</li>
</ul>
<pre class="code literal-block"><span class="nf">primeIntVector</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">VU</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Int</span>
<span class="nf">primeIntVector</span> <span class="n">n</span> <span class="ow">=</span>
    <span class="kr">let</span>
        <span class="n">ls</span> <span class="ow">=</span> <span class="n">genNumberRange</span> <span class="mi">0</span> <span class="n">n</span> <span class="mi">100</span>
    <span class="kr">in</span>
        <span class="kt">VU</span><span class="o">.</span><span class="n">concat</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="n">uncurry</span> <span class="n">primes</span><span class="p">)</span> <span class="n">ls</span> <span class="p">`</span><span class="n">using</span><span class="p">`</span> <span class="n">parList</span> <span class="n">rseq</span><span class="p">)</span>


<span class="nf">primeIntVector'</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">VU</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Int</span>
<span class="nf">primeIntVector'</span> <span class="n">n</span> <span class="ow">=</span>
    <span class="kr">let</span>
        <span class="n">ls</span> <span class="ow">=</span> <span class="n">genNumberRange</span> <span class="mi">0</span> <span class="n">n</span> <span class="mi">100</span>
    <span class="kr">in</span>
        <span class="kt">VU</span><span class="o">.</span><span class="n">concat</span> <span class="o">$</span> <span class="kt">Par</span><span class="o">.</span><span class="n">runPar</span> <span class="o">$</span> <span class="kt">Par</span><span class="o">.</span><span class="n">parMap</span> <span class="p">(</span><span class="n">uncurry</span> <span class="n">primes</span><span class="p">)</span> <span class="n">ls</span>
</pre>


<hr>
<h4>Difference between <code>Par</code> and <code>Eval</code>
</h4>
<ul>
<li>Par Monad <ol>
<li>Always evaluate its value to normal form. It avoids the problem
   about the weak-normal form</li>
<li>The cost of calling <code>runPar</code> function is bigger then <code>runEval</code> </li>
<li>Easy to redefine the scheduling strategy</li>
</ol>
</li>
</ul>
<hr>
<h4>Difference between <code>Par</code> and <code>Eval</code>
</h4>
<ul>
<li>
<p>Eval Monad</p>
<ol>
<li>Need use <code>force</code> function to evaluate its value from weak-head normal
   form to normal form. It’s suitable for lazy data structure</li>
<li>The cost of calling <code>runEval</code> function is free</li>
<li>Provide the speculative parallelism </li>
<li>Eval Monad has more diagnostics in ThreadScope compared Par Monad.</li>
</ol>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/23326920/difference-between-par-monad-and-eval-monad-with-deepseq">Reference</a></p>
</li>
</ul>
<!--- What’s the pitfall of Eval Monad ? --><!--- What’s the pitfall of Par Monad ?--><hr>
<h4>Repa</h4>
<ul>
<li>Repa - REgular PArallel arrays</li>
<li>
<strong>Goal</strong><ul>
<li>efficient numerical array computations in Haskell and run them in
  parallel </li>
</ul>
</li>
<li>It could provides efficient unboxed data computation, but not Par monad and
  Strategy monad   <ul>
<li>Repa also support boxed data.</li>
</ul>
</li>
</ul>
<hr>
<h4>Repa - type</h4>
<ul>
<li>The array type</li>
</ul>
<pre class="code literal-block"><span class="kr">data</span> <span class="kt">Array</span> <span class="n">r</span> <span class="n">sh</span> <span class="n">e</span>
</pre>


<ul>
<li>
<code>r</code> -  representation type </li>
<li>
<code>e</code> - element type </li>
<li>
<code>sh</code> - the shape of array (the dimension(s) of array)</li>
</ul>
<pre class="code literal-block"><span class="kr">data</span> <span class="kt">Z</span> <span class="ow">=</span> <span class="kt">Z</span>    <span class="c1">-- scalar data</span>
<span class="kr">data</span> <span class="n">tail</span> <span class="kt">:.</span> <span class="n">head</span> <span class="ow">=</span> <span class="n">tail</span> <span class="kt">:.</span> <span class="n">head</span>

<span class="kr">type</span> <span class="kt">DIM0</span> <span class="ow">=</span> <span class="kt">Z</span>
<span class="kr">type</span> <span class="kt">DIM1</span> <span class="ow">=</span> <span class="kt">DIM0</span> <span class="kt">:.</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kt">DIM2</span> <span class="ow">=</span> <span class="kt">DIM1</span> <span class="kt">:.</span> <span class="kt">Int</span>
</pre>


<hr>
<h4>Repa - array</h4>
<ul>
<li>how to create an array with <code>Array</code> type ?<ul>
<li>
<code>fromListUnboxed</code> - from list of unboxed type</li>
<li>
<code>fromUnboxed</code> - from the vector with <code>Data.Vector.Unboxed</code> type</li>
<li>
<code>fromFunction</code> - from the shape information to generate the array</li>
<li>... etc</li>
</ul>
</li>
</ul>
<pre class="code literal-block"><span class="nf">fromListUnboxed</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Shape</span> <span class="n">sh</span><span class="p">,</span> <span class="kt">Unbox</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">sh</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="n">sh</span> <span class="n">a</span>
<span class="nf">fromFunction</span> <span class="ow">::</span> <span class="n">sh</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">sh</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">D</span> <span class="n">sh</span> <span class="n">a</span>
<span class="nf">fromUnboxed</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Shape</span> <span class="n">sh</span><span class="p">,</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Vector</span><span class="o">.</span><span class="kt">Unboxed</span> <span class="n">e</span><span class="p">)</span> <span class="ow">::</span> <span class="n">sh</span> <span class="ow">-&gt;</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="n">sh</span> <span class="n">e</span>
</pre>


<!-- 
the major difference between `fromListUnboxed` and `fromUnboxed`
   - `fromListUnboxed` - O(n). Convert a list to an unboxed vector array.
   - `fromUnboxed` - O(1). Wrap an unboxed vector as an array. 
-->

<hr>
<h4>Repa - create array example</h4>
<ul>
<li>Example - create an array</li>
</ul>
<pre class="code literal-block"><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Data.Array.Repa</span> <span class="k">as</span> <span class="n">R</span>
<span class="kt">Prelude</span> <span class="kt">R</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">R</span><span class="o">.</span><span class="n">fromListUnboxed</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="mi">10</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="ow">::</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="kt">DIM1</span> <span class="kt">Int</span>
<span class="kt">Prelude</span> <span class="kt">R</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">a</span> 
<span class="nf">a</span> <span class="ow">::</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="kt">DIM1</span> <span class="kt">Int</span>

<span class="kt">Prelude</span> <span class="kt">R</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">b</span> <span class="ow">=</span>  <span class="kt">R</span><span class="o">.</span><span class="n">fromFunction</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="n">i</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>
<span class="kt">Prelude</span> <span class="kt">R</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">b</span>
<span class="nf">b</span> <span class="ow">::</span> <span class="kt">Array</span> <span class="kt">D</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="kt">Int</span><span class="p">)</span> <span class="kt">Int</span>

<span class="kt">Prelude</span> <span class="kt">R</span> <span class="o">&gt;</span> <span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Vector.Unboxed</span> <span class="k">as</span> <span class="n">VU</span>
<span class="kt">Prelude</span> <span class="kt">R</span> <span class="kt">VU</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">VU</span><span class="o">.</span><span class="n">enumFromN</span> <span class="mi">1</span> <span class="mi">10</span> <span class="ow">::</span> <span class="kt">VU</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Int</span>
<span class="kt">Prelude</span> <span class="kt">R</span> <span class="kt">VU</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">c</span> <span class="ow">=</span> <span class="kt">R</span><span class="o">.</span><span class="n">fromUnboxed</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="p">(</span><span class="kt">VU</span><span class="o">.</span><span class="n">length</span> <span class="n">v</span><span class="p">))</span> <span class="n">v</span>
<span class="kt">Prelude</span> <span class="kt">R</span> <span class="kt">VU</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">c</span>
<span class="nf">c</span> <span class="ow">::</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="kt">Int</span><span class="p">)</span> <span class="kt">Int</span>
</pre>


<hr>
<h4>Repa - array computation</h4>
<ul>
<li>All array will transfer to a delayed array type (ex: <code>Array D sh e</code>)
  after array computations (ex: <code>Repa.map</code>)</li>
</ul>
<pre class="code literal-block"><span class="kt">Repa</span><span class="o">.</span><span class="n">map</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Shape</span> <span class="n">sh</span><span class="p">,</span> <span class="kt">Source</span> <span class="n">r</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span>
     <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">r</span> <span class="n">sh</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">D</span> <span class="n">sh</span> <span class="n">b</span>

<span class="p">(</span><span class="o">+^</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Shape</span> <span class="n">sh</span><span class="p">,</span> <span class="kt">Source</span> <span class="n">r1</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Source</span> <span class="n">r2</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span>
     <span class="kt">Array</span> <span class="n">r1</span> <span class="n">sh</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">r2</span> <span class="n">sh</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">D</span> <span class="n">sh</span> <span class="n">c</span>
</pre>


<hr>
<h4>Repa - compute</h4>
<ul>
<li>
<code>computeS</code> - calculate the array operations in sequentially.</li>
<li>
<code>computeP</code> - the same as <code>computeS</code> but in parallel.<ul>
<li>the purpose of the monad is only to ensure that <code>computeP</code> operations are
  performed in sequence and not nested.<ul>
<li>the simplest way to reduce the monad effect -- <code>runIdentity</code>
</li>
<li>See page p.94 to get more information</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="code literal-block"><span class="nf">computeS</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Load</span> <span class="n">r1</span> <span class="n">sh</span> <span class="n">e</span><span class="p">,</span> <span class="kt">Target</span> <span class="n">r2</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Array</span> <span class="n">r1</span> <span class="n">sh</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">r2</span> <span class="n">sh</span> <span class="n">e</span>
<span class="nf">computeP</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Source</span> <span class="n">r2</span> <span class="n">e</span><span class="p">,</span> <span class="kt">Target</span> <span class="n">r2</span> <span class="n">e</span><span class="p">,</span> <span class="kt">Load</span> <span class="n">r1</span> <span class="n">sh</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span>
    <span class="kt">Array</span> <span class="n">r1</span> <span class="n">sh</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Array</span> <span class="n">r2</span> <span class="n">sh</span> <span class="n">e</span><span class="p">)</span>
</pre>


<hr>
<h4>Repa - array computation example</h4>
<ul>
<li>calculate $e^x = \sum^{\infty}_{n=0}\frac{x^n}{n!} \forall x$</li>
</ul>
<pre class="code literal-block"><span class="kr">import</span> <span class="nn">Data.Array.Repa</span> <span class="k">as</span> <span class="n">R</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Identity</span>

<span class="nf">fact</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="p">]</span>

<span class="nf">enumN</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">D</span> <span class="kt">DIM1</span> <span class="kt">Double</span>
<span class="nf">enumN</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">R</span><span class="o">.</span><span class="n">fromFunction</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="n">i</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">fromIntegral</span> <span class="n">i</span><span class="p">)</span>  

<span class="nf">exp'</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">exp'</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">let</span>
             <span class="n">ns</span> <span class="ow">=</span> <span class="n">enumN</span> <span class="mi">100</span>
             <span class="n">ys</span> <span class="ow">=</span> <span class="kt">R</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">n</span> <span class="ow">-&gt;</span> <span class="p">(((</span><span class="n">fromIntegral</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fact</span> <span class="n">n</span><span class="p">)))</span>
                  <span class="n">ns</span> 
         <span class="kr">in</span>
             <span class="n">runIdentity</span> <span class="o">.</span> <span class="kt">R</span><span class="o">.</span><span class="n">sumAllP</span> <span class="o">$</span> <span class="n">ys</span>
</pre>


wzxhzdk:32

--&gt;

<hr>
<h4>Repa - example</h4>
<ul>
<li>Example - prime numbers</li>
</ul>
<pre class="code literal-block"><span class="nf">primeArray</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">VU</span><span class="o">.</span><span class="kt">Vector</span> <span class="kt">Int</span>
<span class="nf">primeArray</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">let</span>
                   <span class="n">a</span> <span class="ow">=</span> <span class="n">genArray</span> <span class="n">n</span>
                   <span class="n">ps</span> <span class="ow">=</span> <span class="n">runIdentity</span> <span class="o">.</span> <span class="kt">Repa</span><span class="o">.</span><span class="n">computeUnboxedP</span> <span class="o">.</span> <span class="n">primeArrayCheck</span> <span class="o">$</span>
                        <span class="n">a</span> <span class="ow">::</span> <span class="kt">Array</span> <span class="kt">U</span> <span class="kt">DIM1</span> <span class="kt">Int</span>
               <span class="kr">in</span>
                   <span class="kt">VU</span><span class="o">.</span><span class="n">filter</span> <span class="p">(</span><span class="o">/=</span><span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Repa</span><span class="o">.</span><span class="n">toUnboxed</span> <span class="n">ps</span><span class="p">)</span>
</pre>


<hr>
<h4>Conclusion</h4>
<ul>
<li>
<p>The simplest parallel method - parallel map</p>
<ul>
<li>use <code>parMap</code> or <code>parList</code>
</li>
</ul>
</li>
<li>
<p>Repa is useful especially for numeric calculation.</p>
</li>
<li>
<p>The remaining part of <a href="http://chimera.labs.oreilly.com/books/1230000000929">the book</a>
  is about.</p>
<ul>
<li>Parallel programming with GPU (<a href="https://hackage.haskell.org/package/accelerate"><code>Data.Accelerate</code></a>)</li>
<li>Concurrent programming</li>
</ul>
</li>
<li>
<p>Bool unbxoed type ?</p>
</li>
</ul>
</div>
    </div>
    </article><article class="hentry"><header><div class="entry-meta">
      <span class="entry-date date published updated">
        <time datetime="2015-12-27T11:12:30+08:00" title="2015-12-27 11:12">2015-12-27 11:12</time></span>  ·  
      <span class="byline author vcard">Yen3</span>
            ·  <span class="commentline">
        
    <a href="posts/2015/20151227_murmur-text-file-format/#disqus_thread" data-disqus-identifier="cache/posts/2015/20151227_murmur-text-file-format.html">Comments</a>


      </span>
</div>
        <h1 class="p-name entry-title"><a href="posts/2015/20151227_murmur-text-file-format/" class="u-url">murmur (10) - mkd &amp; LaTeX</a></h1>
    </header><div class="e-content entry-content">
    <div>
<p>其實這個 blog 壞掉很久了，因為 nikola 更新之後會強制把整個 <code>output</code> folder 重刷，我之前在上面硬幹用 git 上傳到 github 的方式就不能用了，因為 nikola 已經提供了 <code>nikola github_deploy</code> 的指令，但是暫時沒有東西想寫所以也不理它，今天突然想寫點廢話的時候 ... 覺得還是要修一修了 XD 照著 <a href="https://getnikola.com/handbook.html#deploying-to-github">nikola handbook</a> 的說明，倒也是很快就修好了，而且這個方式也比我之前用的好的多，也可以利用 github 備份整個 source，算是很方便的方式，這樣子我也不用研究 Travis CI 了 XD。</p>
<p>近一兩年來大部分寫筆記的方式都是使用 markdown (mkd)，但是最近應該會重建 LaTeX 的寫作環境，專門拿來做筆記用 (其實我也沒有多少筆記要做 XD)，倒也不是說 mkd 不好，而是自己的龜毛病發作 XD。我自己數學不好，所以其實也沒有多少數學式要寫，用 LaTeX 單純只是圖一個精準而己。寫 mkd 的時候，每個軟體 render 出來的結果不盡相同 (試試 subitem 配合 code block)，暫時解法是以 MacDown 的顯示為基準。目前的想法是速記還是以 mkd 為主，如果要寫長一點的筆記還是會回歸到 LaTeX (XeLaTeX) 上。</p>
<p>2015 年的 LaTeX 中文處理使用 xeCJK 處理起來應該都不會有太大的問題。在 Mac OS X 上的 LaTeX 編輯環境 TeXShop 仍是第一首選。不過因為愛用 vim 的緣故，參考 XOO 的 blog 設定 (<a href="https://xcycl.wordpress.com/2013/01/20/os-x-%E7%9A%84-latex-%E5%AF%AB%E4%BD%9C%E7%92%B0%E5%A2%83/">OS X 的 LATEX 寫作環境</a>, <a href="https://xcycl.wordpress.com/2013/11/10/os-x-%E4%B8%8A%E8%87%AA%E5%8B%95%E7%B7%A8%E8%AD%AF-latex-%E8%88%87%E8%87%AA%E5%8B%95%E6%9B%B4%E6%96%B0/">OS X 上自動編譯 LATEX 與自動更新</a>)，使用上亦相當順暢。</p>
<p>今天也利用空閒時間小小的修改 TeXShop 的 article 及 beamer template，主要是加上 xeCJK support 及 minted package 的 syntax highlighting (終於不是 verbatim 了~!)。重新開始的原因是之前的版面設定檔案隨著硬碟洗掉而消失了，放在自己的 github <a href="https://github.com/yen3/latex_template">repo</a> 上也算是幫自己做備份。</p>
<hr>
<p>看看自己可以撐多久 XD </p>
</div>
    </div>
    </article><article class="hentry"><header><div class="entry-meta">
      <span class="entry-date date published updated">
        <time datetime="2015-10-31T07:22:35+08:00" title="2015-10-31 07:22">2015-10-31 07:22</time></span>  ·  
      <span class="byline author vcard">Yen3</span>
            ·  <span class="commentline">
        
    <a href="posts/2015/20151031_note-kindle-paper-white-2015/#disqus_thread" data-disqus-identifier="cache/posts/2015/20151031_note-kindle-paper-white-2015.html">Comments</a>


      </span>
</div>
        <h1 class="p-name entry-title"><a href="posts/2015/20151031_note-kindle-paper-white-2015/" class="u-url">用了 Kindle Paperwhite 2015 數日感想</a></h1>
    </header><div class="e-content entry-content">
    <ol>
<li>如果你有看大量網頁長文章的需求 (e.g. wiki or 教學文件)，可以利用 send to kindle 這個 chrome plugin 來閱讀。在不考慮排版的情況下，KPW 會比螢幕舒服很多很多。我在 iOS 上是透過第三方軟體達成把看到的網頁經由 send to kindle 這條路送到 kindle 上 XD。</li>
<li>中文雜書還是很少，不過基本上我也不太看 XD 目前是以好讀網站 (比較老版權問題不大的書) 及潑墨書坊為主。如果對簡體中文不排斥的話，其實對岸會有很多嘿嘿嘿的 epub 可以使用 kindlegen 轉成 mobi 在 KPW 上閱讀的，對岸還有多看軟體可以使用，不過我暫時還沒有去嘗試 XD。</li>
<li>英文的雜書的話，基本上是一個練習英文很好的載體，不過不能支持有聲書，但是如果是在 amazon 上買的話，可以用 android or iphone 進行同步。一開始看英文雜書誠心建議從短篇看起。如何利用 KPW 幫你看英文，這其實需要花很多時間說明，在此略過。</li>
<li>英文電腦書，如果買的是正版英文電腦書，基本上都會有 pdf, epub 及 mobi 可供選擇，如果要循序讀的時候，用 kindle 讀 mobi 是最佳的選擇之一。如果想要搜尋或跳著讀的時候，使用 iPad 或電腦是不錯的選擇。我曾經有考慮過 SONY DPT-S1，但是價格太貴，目前買不起。</li>
<li>對於 pdf 的話，如果是滿版 A4 的 pdf 的話，用 KPW 的橫向模式還是太小了 (btw 用 KPW 的橫向看東西有在打電動的感覺 XD)，雙欄論文的話，基本上局部放大是勉強可看的，如果你有很多 pdf 的話，建議還是留一台 iPad 或者是買一台 SONY DPT-S1 在身上 (或者是心一橫直接印出來) 會比較好。</li>
<li>KPW 其實是一個很輕很小的載體 (6 吋，204 克)，一本英文小說大約為 105 g 左右，一本中文雜書大抵是 200 ~ 300 g 左右，英文工具書就更不用說了 XD，其實 KPW 會比很多書來的更好攜帶，只是閱讀習慣需要做出適度的改變。</li>
</ol>
</div>
    </article><article class="hentry"><header><div class="entry-meta">
      <span class="entry-date date published updated">
        <time datetime="2015-10-06T22:10:48+08:00" title="2015-10-06 22:10">2015-10-06 22:10</time></span>  ·  
      <span class="byline author vcard">Yen3</span>
            ·  <span class="commentline">
        
    <a href="posts/2015/20151006_murmur-9-just-for-fun-add-from-0-to-n-in-parallel/#disqus_thread" data-disqus-identifier="cache/posts/2015/20151006_murmur-9-just-for-fun-add-from-0-to-n-in-parallel.html">Comments</a>


      </span>
</div>
        <h1 class="p-name entry-title"><a href="posts/2015/20151006_murmur-9-just-for-fun-add-from-0-to-n-in-parallel/" class="u-url">murmur (9) - Just for fun - Add from 0 to n in parallel</a></h1>
    </header><div class="e-content entry-content">
    <div>
<p>I stuided the <a href="https://hackage.haskell.org/package/repa">repa</a> package today. I discover it supports parallel computation for both boxed type and unboxed type rather then only for unboxed type. It reminds me that I have to read the manual carefully.</p>
<p>Repa supports doing sum computation in parallel (see <code>sumP</code> in <a href="https://hackage.haskell.org/package/repa-3.4.0.1/docs/Data-Array-Repa.html">repa doc</a>). I just write a parallel sum function for fun.</p>
<pre class="code literal-block"><span class="kr">import</span> <span class="nn">Data.Array.Repa</span> <span class="k">as</span> <span class="n">Repa</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Vector.Unboxed</span> <span class="k">as</span> <span class="n">VU</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Identity</span>

<span class="nf">sumR</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">sumR</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">let</span>
            <span class="n">xs</span> <span class="ow">=</span> <span class="kt">VU</span><span class="o">.</span><span class="n">enumFromN</span> <span class="mi">0</span> <span class="n">n</span>
        <span class="kr">in</span>
            <span class="n">runIdentity</span> <span class="p">(</span><span class="kt">Repa</span><span class="o">.</span><span class="n">sumAllP</span> <span class="p">(</span><span class="kt">Repa</span><span class="o">.</span><span class="n">fromUnboxed</span> <span class="p">(</span><span class="kt">Z</span> <span class="kt">:.</span> <span class="kt">VU</span><span class="o">.</span><span class="n">length</span> <span class="n">xs</span><span class="p">)</span> <span class="n">xs</span><span class="p">))</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">show</span> <span class="o">.</span> <span class="n">sumR</span> <span class="o">$</span> <span class="mi">100000000</span>
</pre>


<p>Tomorrow's goal: <a href="https://hackage.haskell.org/package/accelerate">Accelerate package</a>.</p>
</div>
    </div>
    </article><article class="hentry"><header><div class="entry-meta">
      <span class="entry-date date published updated">
        <time datetime="2015-08-27T12:44:18+08:00" title="2015-08-27 12:44">2015-08-27 12:44</time></span>  ·  
      <span class="byline author vcard">Yen3</span>
            ·  <span class="commentline">
        
    <a href="posts/2015/20150827_haskell-practice-cairo/#disqus_thread" data-disqus-identifier="cache/posts/2015/20150827_haskell-practice-cairo.html">Comments</a>


      </span>
</div>
        <h1 class="p-name entry-title"><a href="posts/2015/20150827_haskell-practice-cairo/" class="u-url">[Haskell Practice] Cairo package</a></h1>
    </header><div class="e-content entry-content">
    <div>
<p>That's I tried to use <a href="https://hackage.haskell.org/package/cairo">cairo</a> package to draw something.</p>
<p>The picture is drawed by the l-system formula. You can get more details from the wiki page <a href="https://en.wikipedia.org/wiki/L-system#Example_4:_Koch_curve">L-system: Example 4: Koch curve</a>.</p>
<p>The souce code is not released until I am satisfied with what I write XD.</p>
<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/24606632@N05/20906267942/in/dateposted-public/" title="Practice for L-system"><img src="https://farm6.staticflickr.com/5829/20906267942_c299b1928c.jpg" width="500" height="264" alt="Practice for L-system"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
<p>Update: add practice for <a href="https://en.wikipedia.org/wiki/L-system#Example_6:_Dragon_curve">drgaon curve</a></p>
<p><a data-flickr-embed="true" href="https://www.flickr.com/photos/24606632@N05/20925612021/in/dateposted-public/" title="Practice for dragon curve"><img src="https://farm1.staticflickr.com/640/20925612021_e057007f99.jpg" width="332" height="500" alt="Practice for dragon curve"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script></p>
</div>
    </div>
    </article><article class="hentry"><header><div class="entry-meta">
      <span class="entry-date date published updated">
        <time datetime="2015-07-25T12:57:19+08:00" title="2015-07-25 12:57">2015-07-25 12:57</time></span>  ·  
      <span class="byline author vcard">Yen3</span>
            ·  <span class="commentline">
        
    <a href="posts/2015/20150725_murmur-8-keep-going/#disqus_thread" data-disqus-identifier="cache/posts/2015/20150725_murmur-8-keep-going.html">Comments</a>


      </span>
</div>
        <h1 class="p-name entry-title"><a href="posts/2015/20150725_murmur-8-keep-going/" class="u-url">murmur (8) - Keep going</a></h1>
    </header><div class="e-content entry-content">
    <div>
<p>No news is good news. That's what gwchen told me. 
How about me in the recent life ? Just back to the begining for learning something.</p>
<p>I have left my last job for four monthes. In these days, I have </p>
<ul>
<li>Learned<ul>
<li>basic Haskell programming (including basic Monad)</li>
<li>basic parallel and concurrent programming</li>
<li>basic linux system programming through reading <a href="http://man7.org/tlpi/">TLPI</a>
</li>
</ul>
</li>
<li>Practiced English<ul>
<li>Watch CNN Student news for one and half month</li>
<li>Read/ Listen several Time articles in one month </li>
</ul>
</li>
</ul>
<p>What's the next step ? I don't know.
The only thing I know is that I will following my mind.</p>
<!-- I have some interesting in parallel programming, especially combining with FP. -->

<!-- Althgough it's all about monads for parallel programming in Haskell, it's easy
to start write program with parallel paradigm in haskell. The basic method is 
to add parallel strategy to your `map` function. The next step is to locate the
data dependency among the program. I have only learned the two steps of parallel
programming in Haskell. -->
</div>
    </div>
    </article><article class="hentry"><header><div class="entry-meta">
      <span class="entry-date date published updated">
        <time datetime="2015-07-12T18:46:49+08:00" title="2015-07-12 18:46">2015-07-12 18:46</time></span>  ·  
      <span class="byline author vcard">Yen3</span>
            ·  <span class="commentline">
        
    <a href="posts/2015/20150712_haskell-practice-primes/#disqus_thread" data-disqus-identifier="cache/posts/2015/20150712_haskell-practice-primes.html">Comments</a>


      </span>
</div>
        <h1 class="p-name entry-title"><a href="posts/2015/20150712_haskell-practice-primes/" class="u-url">[Haskell Practice] Primes</a></h1>
    </header><div class="e-content entry-content">
    <div>
<p>這個問題以前就寫過，只是剛好今天有機會重寫一下。</p>
<pre class="code literal-block"><span class="kr">module</span> <span class="nn">Prime</span> <span class="kr">where</span>

<span class="nf">sqrtInt</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">sqrtInt</span> <span class="ow">=</span> <span class="n">ceiling</span> <span class="o">.</span> <span class="n">sqrt</span> <span class="o">.</span> <span class="n">fromIntegral</span>

<span class="nf">genInspectList</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">genInspectList</span> <span class="n">n</span>
    <span class="o">|</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="ow">=</span> <span class="kt">[]</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">)</span> <span class="o">$</span> <span class="mi">5</span> <span class="kt">:</span> <span class="p">[</span><span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

<span class="nf">prime</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">prime</span> <span class="n">x</span> <span class="n">is</span> <span class="ow">=</span> <span class="n">all</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">y</span> <span class="o">/=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;=</span> <span class="n">sqrtInt</span> <span class="n">x</span><span class="p">)</span> <span class="n">is</span><span class="p">)</span>

<span class="nf">primes</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">primes</span> <span class="n">x</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">=</span> <span class="kt">[]</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">++</span> <span class="n">filter</span> <span class="p">(`</span><span class="n">prime</span><span class="p">`</span> <span class="n">is</span><span class="p">)</span> <span class="n">ps</span>
        <span class="kr">where</span> <span class="n">is</span> <span class="ow">=</span> <span class="n">primes</span> <span class="p">(</span><span class="n">sqrtInt</span> <span class="n">x</span><span class="p">)</span>
              <span class="n">ps</span> <span class="ow">=</span> <span class="n">genInspectList</span> <span class="n">x</span>
</pre>


<p>ghci 執行結果如下</p>
<pre class="code literal-block">*Prime&gt; primes 100
[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
</pre>
</div>
    </div>
    </article><article class="hentry"><header><div class="entry-meta">
      <span class="entry-date date published updated">
        <time datetime="2015-06-25T23:41:26+08:00" title="2015-06-25 23:41">2015-06-25 23:41</time></span>  ·  
      <span class="byline author vcard">Yen3</span>
            ·  <span class="commentline">
        
    <a href="posts/2015/20150625_haskell-practice-mandelbrot-binary/#disqus_thread" data-disqus-identifier="cache/posts/2015/20150625_haskell-practice-mandelbrot-binary.html">Comments</a>


      </span>
</div>
        <h1 class="p-name entry-title"><a href="posts/2015/20150625_haskell-practice-mandelbrot-binary/" class="u-url">[Haskell Practice] Mandelbrot set</a></h1>
    </header><div class="e-content entry-content">
    <div>
<p>老實說，原本以為會寫很一篇比較長的 blog post ，但是想想之後，做的都是簡單的事情，所以就簡單記錄一下。</p>
<p>測試的編譯指令是 <code>ghc -O2 Mandelbrot.hs -rtsopts -threaded -fllvm</code></p>
<p>程式碼如下。基本上 Mandelbrot.hs 可以利用 <code>./Mandelbrot par 100 +RTS -N2 -s</code> 產生資料，該 output data 的前半部是 x points，後半部是 y points。再利用 <code>python plotMandelbrot.py</code> 把圖畫出來。</p>
<p>在 2010 late MBP15 (Intel Core i5 2.4 Ghz, 8Gb) 上跑 <code>./Mandelbrot par 100 +RTS -N2 -s</code> (2 threads) 約 25 secs 左右，單核心約 45 secs 左右，這速度是不快，不過暫時應該不會再改了，因為還有其他的資料想看 ... (<a href="http://chimera.labs.oreilly.com/books/1230000000929">熱帶魚</a> 在 Chapter 6 也實作 Mandelbrot，使用 GPU 加速，只花了 10 secs，而且精細的多)。 </p>
<script src="https://gist.github.com/yen3/8bc2f108cb8b6739edd7.js"></script><p>最底下附上第一版程式，相較於最後一版其實做了不少修改如上。</p>
<ol>
<li>一開始使用 <code>Complex Double</code> 做計算，後來改用 <code>(Double,Double)</code>
</li>
<li>原生的 List 在 2 threads 以上的 GC 時間會特長 (沒有特地去找原因)，改用 <code>Data.Vector</code> 實作。</li>
<li>一開始就產生全部的點去做運算耗費太多的時間，改傳點的平面範圍要算的時候再產生點。</li>
<li>善用 <a href="https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/bang-patterns.html">Bang patterns</a> 限制一些參數為 strict</li>
</ol>
<pre class="code literal-block"><span class="kr">import</span> <span class="nn">Data.Complex</span>
<span class="kr">import</span> <span class="nn">Data.Binary.Put</span>
<span class="kr">import</span> <span class="nn">Data.Binary.IEEE754</span> <span class="p">(</span><span class="nf">putFloat64le</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy</span> <span class="k">as</span> <span class="n">BL</span>

<span class="nf">maxIteration</span> <span class="ow">::</span> <span class="kt">Integer</span> 
<span class="nf">maxIteration</span> <span class="ow">=</span> <span class="mi">3000</span> 

<span class="nf">pointSize</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="nf">pointSize</span> <span class="ow">=</span> <span class="mi">2000</span> 

<span class="nf">isMandelPoint</span> <span class="ow">::</span> <span class="kt">Complex</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isMandelPoint</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">q</span> <span class="n">maxIteration</span> <span class="n">p</span>
    <span class="kr">where</span> <span class="n">q</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Complex</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
          <span class="n">q</span> <span class="mi">0</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span> 
          <span class="n">q</span> <span class="n">t</span> <span class="n">z</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="kr">then</span> <span class="kt">False</span> <span class="kr">else</span> <span class="n">q</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">z'</span>
              <span class="kr">where</span> <span class="n">z'</span> <span class="ow">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">z</span><span class="o">^</span><span class="mi">2</span>
                    <span class="n">r</span> <span class="ow">=</span> <span class="n">realToFrac</span> <span class="o">.</span> <span class="n">realPart</span> <span class="o">.</span> <span class="n">abs</span> <span class="o">$</span> <span class="n">z'</span> 

<span class="nf">pointList</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)]</span>
<span class="nf">pointList</span> <span class="p">(</span><span class="n">xBegin</span><span class="p">,</span> <span class="n">xEnd</span><span class="p">)</span> <span class="p">(</span><span class="n">yBegin</span><span class="p">,</span> <span class="n">yEnd</span><span class="p">)</span> <span class="ow">=</span>
    <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">axis</span> <span class="n">xBegin</span> <span class="n">xEnd</span><span class="p">,</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">axis</span> <span class="n">yBegin</span> <span class="n">yEnd</span><span class="p">]</span> 
    <span class="kr">where</span> <span class="n">axis</span> <span class="n">b</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">e</span><span class="p">)</span> <span class="o">$</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">repeat</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">scanl1</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">$</span> <span class="n">repeat</span> <span class="n">dist</span><span class="p">)</span>
              <span class="kr">where</span> <span class="n">dist</span> <span class="ow">=</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">fromIntegral</span> <span class="n">pointSize</span>

<span class="nf">mandelPointList</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)]</span>
<span class="nf">mandelPointList</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">isMandelPoint</span> <span class="o">$</span> <span class="n">x</span> <span class="kt">:+</span> <span class="n">y</span><span class="p">)</span>

<span class="nf">serDoublesData</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Put</span>
<span class="nf">serDoublesData</span> <span class="n">zs</span> <span class="ow">=</span> <span class="n">mapM_</span> <span class="n">putFloat64le</span> <span class="o">$</span> <span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span> 
                    <span class="kr">where</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span> <span class="ow">=</span>  <span class="n">unzip</span> <span class="n">zs</span>

<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="kr">let</span> <span class="n">fn</span> <span class="ow">=</span> <span class="s">"mandelbot.bin"</span> 
          <span class="kr">let</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">mandelPointList</span> <span class="o">$</span> <span class="n">pointList</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
          <span class="kt">BL</span><span class="o">.</span><span class="n">writeFile</span> <span class="n">fn</span> <span class="p">(</span><span class="n">runPut</span> <span class="p">(</span><span class="n">serDoublesData</span> <span class="n">p</span><span class="p">))</span>
          <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"Finish write "</span> <span class="o">++</span> <span class="n">fn</span>
</pre>


<p>練習寫這個程式算是長知識，因為很多基本的事其實都不太會，做個記錄哩。</p>
</div>
    </div>
    </article><article class="hentry"><header><div class="entry-meta">
      <span class="entry-date date published updated">
        <time datetime="2015-06-24T10:56:14+08:00" title="2015-06-24 10:56">2015-06-24 10:56</time></span>  ·  
      <span class="byline author vcard">Yen3</span>
            ·  <span class="commentline">
        
    <a href="posts/2015/20150624_haskell-practice-execute-shell-command/#disqus_thread" data-disqus-identifier="cache/posts/2015/20150624_haskell-practice-execute-shell-command.html">Comments</a>


      </span>
</div>
        <h1 class="p-name entry-title"><a href="posts/2015/20150624_haskell-practice-execute-shell-command/" class="u-url">[Haskell Practice] Execute shell command</a></h1>
    </header><div class="e-content entry-content">
    <div>
<p>算是今天做的小練習，為了要讓 <code>ghc</code> 有 <code>-fllvm</code> 選項，發現 ghc 支援的 llvm 版本為 3.3，所以自己寫了一個程式練習執行 shell command</p>
<pre class="code literal-block"><span class="kr">import</span> <span class="nn">System.Directory</span>
<span class="kr">import</span> <span class="nn">System.FilePath.Posix</span>
<span class="kr">import</span> <span class="nn">Data.String.Utils</span>
<span class="kr">import</span> <span class="nn">Control.Applicative</span>
<span class="kr">import</span> <span class="nn">System.Process</span>

<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">f</span> <span class="ow">&lt;-</span> <span class="n">filter</span> <span class="p">(</span><span class="n">endswith</span> <span class="s">"-3.3"</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">getDirectoryContents</span> <span class="s">"./"</span>
          <span class="kr">let</span> <span class="n">ori_f</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="s">"../../Cellar/llvm33/3.3_1/bin/"</span> <span class="o">&lt;/&gt;</span><span class="p">)</span> <span class="n">f</span>
          <span class="kr">let</span> <span class="n">ln_f</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">((</span><span class="o">&lt;/&gt;</span><span class="p">)</span> <span class="s">"llvm33"</span> <span class="o">.</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">take</span> <span class="p">(</span><span class="n">length</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="n">x</span><span class="p">))</span> <span class="n">f</span>
          <span class="n">mapM_</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n'</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">readProcess</span> <span class="s">"ln"</span> <span class="p">[</span><span class="s">"-s"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n'</span><span class="p">]</span> <span class="s">""</span><span class="p">)</span> <span class="p">(</span><span class="n">zip</span> <span class="n">ori_f</span> <span class="n">ln_f</span><span class="p">)</span>
</pre>


<p>在執行完 <code>brew install homebrew/versions/llvm33</code> 且建立好 <code>/usr/local/bin/llvm33</code> 資料夾後在 <code>/usr/local/bin</code> 用 <code>runhaskell</code> 執行 就可以了。</p>
<p>只是單純留下來備忘，有些 function 也是臨時查的 XD。</p>
</div>
    </div>
    </article><nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="index-5.html" rel="next">Older posts</a>
            </li>
        </ul></nav><script>var disqus_shortname="yen3snote";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
    
    <div class="footer-wrapper">
        <footer role="contentinfo"><p>Contents © 2016         <a href="mailto:yen3rc@gmail.com">Yen3</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>

    
    
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script><script src="assets/js/scripts.min.js"></script>
</body>
</html>
